= The `systemctl-extra` CLI Tool

== Overview

The `systemctl-extra` CLI tool is designed to enhance the functionality of the `systemctl edit` command,
allowing users to easily create and manage "drop-in" configuration files for systemd services.


== Using the Editor

To test this enhanced edit command, follow these steps:

=== Set Your EDITOR Environment Variable (Optional but Recommended):

For the edit command to open your preferred text editor, ensure the EDITOR (or VISUAL) environment variable is set. 
If it's not set, the command will fall back to vim (on Unix-like systems) or notepad.exe (on Windows).

On Linux/macOS (Bash/Zsh):
[source,bash]
----
export EDITOR="nvim" # Or vim, nano, code --wait, etc.
----

On Windows (PowerShell):
[source,PowerShell]
----
$env:EDITOR="code --wait" # Or notepad.exe, notepad++.exe, etc.
----

The --wait flag for editors like VS Code is crucial as it tells the CLI to pause until the editor is closed, 
mimicking the traditional behavior of terminal-based editors.

=== Create a Mock Generated Unit File:

For testing the --trans flag, you need a dummy file that resembles a "generated unit file" and contains a SourcePath. 
Create a file named my-generated-unit.service (or any name) in your project root with the following content:

my-generated-unit.service
[source,INI]
----
# This is a generated unit file
# Do not edit this file directly!
[Unit]
Description=My Generated Service
SourcePath=/usr/lib/systemd/system/my-actual-source.service

[Service]
ExecStart=/usr/bin/my-app
----

(Note: The SourcePath value doesn't need to be a real file path for this example, just a string that looks like one.)


=== Run the edit Command:

Execute the command with a unit name. 
You don't need to specify a file path; the tool will figure out the "drop-in" location.
[source,Bash]
----
cargo run -- edit my-service.service
----

This will:

* Print messages indicating the creation of a directory (if it doesn't exist) and the attempt to open the file.
* Launch your configured editor to the path ./.mycli_units/my-service.service.d/override.conf relative to where you ran cargo run.
* If the directory or file didn't exist, they'll be created automatically.

=== Run with a Line Number:
You can also specify a line number, 
and the editor will attempt to open the file at that exact line (if the editor supports it).
[source,Bash]
----
cargo run -- edit another-unit.service --line 10
----

This will open ./.mycli_units/another-unit.service.d/override.conf and try to jump to line 10.

=== Run wit '--trans' Flag:

[source,bash]
----
cargo run -- edit my-generated-unit.service --trans --line 5
----

This combines the `--trans` parsing with the request to jump to line 5 in the derived drop-in file.


=== Inspect the Created Files:

After running the command, check your current working directory. You should find a new directory structure like this:

[source,plaintext]
----
.
└── .mycli_units/
    ├── my-service.service.d/
    │   └── override.conf
    └── another-unit.service.d/
        └── override.conf
----

This demonstrates how the tool creates and manages the "drop-in" configuration files, 
mirroring systemctl edit's approach.

== Enhanced `list` Command


=== Basic Listing:

Run the list command without any arguments. It should display all your mock unit files in a tabular format.
[source,Bash]
----
cargo run -- list
----

You should see output similar to:
[source,plaintext]
----
UNIT FILE                                      STATE           VENDOR PRESET
--------------------------------------------------------------------------------
database.service                               enabled         enabled
my-web-app.service                             enabled         enabled
system-monitor.service                         enabled         enabled
utility.service                                enabled         enabled
----

=== Filtering and Output Options:

The `list` command supports filtering and output formatting similar to `systemctl list-unit-files`.

==== Filtering by Tag:

Use the --filter argument to search for specific tags in the [X-extra] section of your unit files.
[source,Bash]
----
cargo run -- list --filter web_service
----

Expected output:
[source,plaintext]
----
UNIT FILE                                      STATE           VENDOR PRESET
--------------------------------------------------------------------------------
my-web-app.service                             enabled         enabled
----
Try another filter:
[source,Bash]
----
cargo run -- list --filter backend
----

Expected output:
[source,Bash]
----
UNIT FILE                                      STATE           VENDOR PRESET
--------------------------------------------------------------------------------
database.service                               enabled         enabled
----

==== JSON Output:
Use the --output json argument to get the results in a JSON array format.

[source,Bash]
----
cargo run -- list --output json --filter frontend
----

Expected output (prettified for readability):
[source,JSON]
----
[
  {
    "unit_file": "my-web-app.service",
    "state": "enabled",
    "vendor_preset": "enabled"
  }
]
----

You can also get all unit files in JSON:
[source,Bash]
----
cargo run -- list --output json
----

==== Disabling Pager (--no-pager):

If your terminal typically pipes long output to a pager (less or more), use --no-pager to print directly to stdout.
[source,Bash]
----
cargo run -- list --no-pager
----


The output will scroll directly in your terminal without being caught by a pager. This is particularly noticeable if you have many mock unit files.

You can combine it with other options:
[source,Bash]
----
cargo run -- list --output json --no-pager
----

This list command now provides powerful filtering and output capabilities, similar to systemctl list-unit-files, with mock data and basic parsing.

